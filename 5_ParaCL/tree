parser::symbol_type yylex (driver &drv);

class tree_dump {

    int num = 0;

    public:

    void graph_node(const node_t *node, std::ofstream& file) {
        if (node == nullptr)
            return;

        int curr = num;

        if (node->type == node_type::BINOP) {
            file << "\tnode" << num << " [shape = \"invtriangle\", style = \"filled\", fillcolor = \"red\", label = \"" << node->operation << "\"];\n";
            num++;
        } else if (node->type == node_type::UNOP) {
            file << "\tnode" << num << " [shape = \"record\", fontcolor = \"white\", style = \"filled\", fillcolor = \"grey28\", label = \"" << node->operation << "\"];\n";
            num++;
        } else if (node->type == node_type::NUMBER) {
            file << "\tnode" << num << " [shape = \"record\", fontcolor = \"white\", style = \"filled\", fillcolor = \"greenyellow\", label = \"" << node->value << "\"];\n";
            num++;
        } else if (node->type == node_type::ASSIGN) {
            file << "\tnode" << num << " [shape = \"diamond\", fontcolor = \"white\", style = \"filled\", fillcolor = \"gold\", label = \"" << "=" << "\"];\n";
            num++;
        } else if (node->type == node_type::VARIABLE) {
            file << "\tnode" << num << " [shape = \"circle\", fontcolor = \"white\", style = \"filled\", fillcolor = \"lightskyblue1\", label = \"" << node->name->name << "\"];\n";
            num++;
        }

        graph_node(node->lhs, file);
        graph_node(node->rhs, file);

        if (!curr)
            num = 0;
        return;
    }

    void connect_node(const node_t *node, std::ofstream& file) {
        if ((node->lhs == nullptr) && (node->rhs == nullptr))
            return;

        int curr = num;

        if (node->lhs != nullptr) {
            num++;
            file << "node" << curr << " -> node" << num << ";\n";

            connect_node(node->lhs, file);
        }

        if (node->rhs != nullptr) {
            num++;
            file << "node" << curr << " -> node" << num << ";\n";

            connect_node(node->rhs, file);
        }

        if (!curr)
            num = 0;
        return;
    }

};

class tree_t {

    node_t *root;

    public:

    void dump() const {
        std::ofstream file("tree_dump.dot");
        file << "digraph tree {\n";

        tree_dump dump{};
        dump.graph_node(root, file);
        dump.connect_node(root, file);

        file << "}";
        return;
    }

};